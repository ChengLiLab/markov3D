---
title: "Using markov3d to analyze Hi-C data"
author: "Yinan Wang"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Introduction

The R package markov3d is used to compute the steady-state distribution of 
randomly moving biological molecules on the genome. For a detail description of
our package, please refer "Dynamic chromatin accessibility modeled by Markov 
process of randomly-moving molecules in the 3D genome."

## Input

The input of our model should be a raw Hi-C matrix. For example, the raw output
of HicPro. Please note that you don't need to normalize the matrix because our
model will do ICE normalization for you. 
However, if you have the normalized matrix, feel free to skip our model's 
normalizatoin step.

```{r, eval = FALSE}
library(markov3d)
require("HiCDataHumanIMR90")
data(Dixon2012_IMR90)
imr90_chr1 <- hic_imr90_40$chr1chr1
resolution <- 40e3
```

## Preprocess

During the preprocess step, we will ICE normalize Hi-C raw matrix and further
apply shortest-path algorithm to correct bias of cross-linking.

```{r, eval = FALSE}
imr90_ice <- ICENormalization(imr90_chr1)
imr90_sp <- ShortestPathCorrection(imr90_ice, resolution)
imr90_ice_mat <- as.matrix(intdata(imr90_ice))
colnames(imr90_ice_mat) <- (as.numeric(colnames(imr90_ice_mat)) - 1) * resolution
rownames(imr90_ice_mat) <- colnames(imr90_ice_mat)
colnames(imr90_sp) <- colnames(imr90_ice_mat)
rownames(imr90_sp) <- colnames(imr90_ice_mat)
```

Next, we remove centromere and unmapped regions.

```{r, eval = FALSE}
data("centromere.pos")
centromere <- c(dplyr::filter(centromere.pos, chr == "chr1")[["start"]],
                dplyr::filter(centromere.pos, chr == "chr1")[["end"]])
unmapped_region <- colnames(imr90_ice_mat)[colSums(imr90_ice_mat) == 0]
imr90_sp <- RemoveRegions(imr90_sp, centromere, unmapped_region, resolution)
```

## Estimate transition matrix

Once we finish the preprocess step, we could extimate the transtion matrix from
the normalized matrix. We provide two estimation algorithm, one is based on 
Binomial model, the other is based on Browian model.

```{r, eval = FALSE}
transition_mat <- EstimateTransitionMat(imr90_ice_mat, imr90_sp)
```

## Compute steady-state probability

Finally we will compute the steady-state probability from the transition matrix.

```{r, eval = FALSE}
ssd <- ComputeSSD(transition_mat)
```

